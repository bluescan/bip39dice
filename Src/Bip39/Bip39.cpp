// Bip39.cpp
//
// Bip39 interface.
//
// Copyright (c) 2021 Tristan Grimmer.
// Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
// granted, provided that the above copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

#include <Foundation/tList.h>
#include <Foundation/tHash.h>
#include <System/tPrint.h>
#include <Math/tRandom.h>
#include "Bip39.h"


int Bip39::GetNumEntropyBits(int numWords)
{
	switch (numWords)
	{
		case 12:	return 128;
		case 15:	return 160;
		case 18:	return 192;
		case 21:	return 224;
		case 24:	return 256;
	}
	return 0;
}


int Bip39::GetNumEntropyWords(int numBits)
{
	switch (numBits)
	{
		case 128:	return 12;
		case 160:	return 15;
		case 192:	return 18;
		case 224:	return 21;
		case 256:	return 24;
	}
	return 0;
}


bool Bip39::ComputeWordsFromEntropy
(
	tList<tStringItem>& words,
	tbit256& entropy,
	int numBits,
	Bip39::Dictionary::Language lang
)
{
	// From BIP-39
	//
	// First, an initial entropy of ENT bits is generated. A checksum is generated by taking the first
	// ENT / 32 bits of its SHA256 hash. This checksum is appended to the end of the initial entropy.
	// Next, these concatenated bits are split into groups of 11 bits, each encoding a number from
	// 0-2047, serving as an index into a wordlist. Finally, we convert these numbers into words and
	// use the joined words as a mnemonic sentence.	
	int numWords = GetNumEntropyWords(numBits);
	if (!numWords)
		return false;

	// Compute the SHA-256 hash of the entropy.
	uint8 entropyByteArray[32];
	int numEntropyBytes = numBits/8;
	for (int b = 0; b < numEntropyBytes; b++)
		entropyByteArray[b] = entropy.GetByte(numEntropyBytes - b - 1);
	tuint256 sha256 = tHash::tHashDataSHA256(entropyByteArray, numEntropyBytes);

	uint64 chanNorm = tSystem::tChannel_Verbosity1;
	uint64 chanVerb = tSystem::tChannel_Verbosity2;
	tPrintf(chanVerb | chanNorm, "SHA256: %0_64|256X\n", sha256);

	// How many of the first bits do we need?
	int numHashBitsNeeded = numBits / 32;
	uint8 firstBits = sha256.GetByte(31);
	firstBits >>= (8-numHashBitsNeeded);
	tPrintf(chanVerb, "The first %d bits of the sha are: %08b\n", numHashBitsNeeded, firstBits);

	// We now need to store the entropy and the first bits of the sha in a single variable. We make one
	// big enough for the 24-word case: 264 bits. Just for efficiency, we'll use 288, since internally
	// the fixed int class uses 32-bit ints to store their value (and 288 is divisible by 32).
	// Actually, we'll just use 512, as the tPrintf supports that size.
	tuint512 entropyAndChecksum;
	entropyAndChecksum.MakeZero();
	for (int r = 0; r < entropy.GetNumElements(); r++)
		entropyAndChecksum.RawElement(r) = entropy.GetElement(r);

	entropyAndChecksum <<= numHashBitsNeeded;
	entropyAndChecksum |= firstBits;
	tPrintf(chanVerb, "EntropyAndChecksum\n");
	tPrintf(chanVerb, "%0_512|512b\n", entropyAndChecksum);

	// Next we make an array for our word indices. We will be filling it in backwards to
	// avoid extra shift operations. We just shift by 11 each time.
	uint32 wordIndices[24];
	for (int w = 0; w < numWords; w++)
	{
		uint32 wordIndex = entropyAndChecksum & tuint512(0x000007FF);
		tAssert((wordIndex >= 0) && (wordIndex < 2048));
		wordIndices[w] = wordIndex;
		entropyAndChecksum >>= 11;
	}

	// And finally we put the words on the list in the correct order.
	for (int w = 0; w < numWords; w++)
	{
		uint32 wordIndex = wordIndices[numWords - w - 1];
		tString word = Bip39::Dictionary::GetWord(wordIndex, lang);
		words.Append(new tStringItem(word));
	}

	// Before leaving let's clear the local entropy variables. @todo Make sure this can't get optimized away.
	for (int w = 0; w < numWords; w++)
		wordIndices[w] = -1;
	for (int b = 0; b < 32; b++)
		entropyByteArray[b] = 0;
	entropyAndChecksum.MakeZero();

	return true;
}


void Bip39::ClearEntropy(tbit256& entropyBits)
{
	// We're going to overwrite the entropy memory a few times here to protect against hardware snooping
	// and memory persistence. Entropy is declared volatile. @todo Check asm for Clang, GCC, and MSVC.
	volatile uint32* entropy = &entropyBits.GetElement(0);
	int numElems = entropyBits.GetNumElements();
	for (int e = 0; e < numElems; e++) entropy[e] = 0x00000000;
	for (int e = 0; e < numElems; e++) entropy[e] = tMath::tRandom::tGetBits();
	for (int e = 0; e < numElems; e++) entropy[e] = 0xFFFFFFFF;
	for (int e = 0; e < numElems; e++) entropy[e] = tMath::tRandom::tGetBits();
	entropyBits.Clear();
}
